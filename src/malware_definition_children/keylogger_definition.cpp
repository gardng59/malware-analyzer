#include "../import_data.h"
#include "../malware_definition.h"
#include "keylogger_definition.h"
#include <vector>
#include <string>
#include <iostream>

KeyloggerDefinition::KeyloggerDefinition(): MalwareDefinition()
{
	this->name = "keylogger";
	
	std::vector<ImportData*> imports;

	this->imports_used = imports;
}

double KeyloggerDefinition::calculateProbability(std::vector<ImportData*> imports)
{
	double probability = 0;

	// Used in example keylogger https://gist.githubusercontent.com/patilswapnilv/7338783/raw/04ff7fe62fde513786dbdfb30511334fca994694/KeyLogger%2520(%2520C%2520Program)%2520
	std::string find_window ("user32.findwindow");
	bool find_window_matched = false;
	std::string find_window_a ("user32.findwindowa");
	bool find_window_a_matched = false;
	std::string find_window_w = ("user32.findwindoww");
	bool find_window_w_matched = false;
	std::string show_window = ("user32.showwindow");
	bool show_window_matched = false;

	// Used in example keylogger https://codereview.stackexchange.com/questions/46980/windows-keylogger-in-c
	// getasynckeystate/keystate
	// set/unset hooks
	std::string get_message ("user32.getmessage");
	bool get_message_matched = false;
	std::string register_hotkey ("user32.registerhotkey");
	bool register_hotkey_matched = false;

	// System hook keylogger imports according to https://securelist.com/keyloggers-how-they-work-and-how-to-detect-them-part-1/36138/
	std::string set_hook ("user32.setwindowshookex");
	bool set_hook_matched = false;
	std::string set_hook_a ("user32.setwindowshookexa");
	bool set_hook_a_matched = false;
	std::string set_hook_w ("user32.setwindowshookexw");
	bool set_hook_w_matched = false;
	std::string unhook ("user32.unhookwindowshookex");
	bool unhook_matched = false;

	// cyclical information keyboard request keylogger imports according to https://securelist.com/keyloggers-how-they-work-and-how-to-detect-them-part-1/36138/
	std::string get_async_key_state ("user32.getasynckeystate");
	bool get_async_key_state_matched = false;
	std::string get_key_state ("user32.getkeystate");
	bool get_key_state_matched = false;
	std::string get_keyboard_state ("user32.getkeyboardstate");
	bool get_keyboard_state_matched = false;

	for (std::vector<ImportData*>::iterator iter = imports.begin(); iter != imports.end(); iter++)
    {
		std::string *curr_string ((*iter)->toString());

		for (unsigned i = 0; i < curr_string->size(); i++)
		{
			char lower_char = (char)tolower(curr_string->at(i));
			char lower_c_str[1];
			lower_c_str[0] = lower_char;
			std::string lower (&lower_c_str[0]);
			curr_string->replace(i, 1, lower);
		}

		if (*curr_string == get_message)
		{
			get_message_matched = true;
			continue;
		}
		if (*curr_string == register_hotkey)
		{
			register_hotkey_matched = true;
			continue;
		}
		if (*curr_string == find_window)
		{
			find_window_matched = true;
			continue;
		}
		if (*curr_string == find_window_a)
		{
			find_window_a_matched = true;
			continue;
		}
		if (*curr_string == find_window_w)
		{
			find_window_w_matched = true;
			continue;
		}
		if (*curr_string == show_window)
		{
			show_window_matched = true;
			continue;
		}
		if (*curr_string == set_hook)
		{
			set_hook_matched = true;
			continue;
		}
		if (*curr_string == set_hook_a)
		{
			set_hook_a_matched = true;
			continue;
		}
		if (*curr_string == set_hook_w)
		{
			set_hook_w_matched = true;
			continue;
		}
		if (*curr_string == unhook)
		{
			unhook_matched = true;
			continue;
		}
		if (*curr_string == get_async_key_state)
		{
			get_async_key_state_matched = true;
			continue;
		}
		if (*curr_string == get_key_state)
		{
			get_key_state_matched = true;
			continue;
		}
		if (*curr_string == get_keyboard_state)
		{
			get_keyboard_state_matched = true;
		}
    }

    if ((find_window_matched || find_window_a_matched || find_window_w_matched) && show_window_matched)
    {
    	if (probability < 50)
    	{
    		probability = 50;
    	}
    }
    else if (find_window_matched || find_window_a_matched || find_window_w_matched)
    {
    	if (probability < 30)
    	{
    		probability = 30;
    	}
    }

    if (get_message_matched && register_hotkey_matched)
    {
    	if (probability < 50)
		{
			probability = 50;
		}
    }
    else if (get_message_matched || register_hotkey_matched)
   	{
    	if (probability < 30)
		{
			probability = 30;
		}
    }

	if ((set_hook_matched || set_hook_a_matched || set_hook_w_matched) && unhook_matched)
	{
		if (get_message_matched && register_hotkey_matched)
	    {
	    	if (probability < 90)
			{
				probability = 90;
			}
	    }
	    else if (get_message_matched || register_hotkey_matched)
	   	{
	    	if (probability < 75)
			{
				probability = 75;
			}
	    }
	    else if (probability < 60)
		{
			probability = 60;
		}
	}
	else if (set_hook_matched || set_hook_a_matched || set_hook_w_matched)
	{
		if (get_message_matched && register_hotkey_matched)
	    {
	    	if (probability < 75)
			{
				probability = 75;
			}
	    }
	    else if (get_message_matched || register_hotkey_matched)
	   	{
	    	if (probability < 60)
			{
				probability = 60;
			}
	    }
	    else if (probability < 40)
		{
			probability = 40;
		}
	}

	if (get_async_key_state_matched || get_key_state_matched || get_keyboard_state_matched)
	{
		if (probability < 50)
		{
			probability = 50;
		}
	}

	return probability;
}

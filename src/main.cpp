#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <string.h>
#include <vector>
#include <gtk/gtk.h>
#include "import_data.h"
#include "malware_definition.h"
#include "malware_definition_children/keylogger_definition.h"
#include "malware_definition_children/screen_capture_definition.h"
#include "malware_definition_children/antidebugging_definition.h"

typedef struct file_scan_data {
	GtkBuilder *builder;
	std::string *selected_path;
} file_scan_data;

void setFile(GtkWidget *widget, gpointer data)
{
	GFile *selected = gtk_file_chooser_get_file(GTK_FILE_CHOOSER(widget));
	*((std::string*)data) = g_file_get_path(selected);
}

void analyzeFile(std::string in_file, std::string *output = NULL)
{
	std::vector<ImportData*> imports;
	std::vector<std::string> strings;

	std::string readpe_command = in_file;
	readpe_command = "readpe --format csv -i " + readpe_command;
	const char* c_str_readpe_command = readpe_command.c_str();

	FILE *result;
	char buffer[255];
	result = popen(c_str_readpe_command, "r");

	std::string current_library;
	
	while(fgets(buffer, 255, result) != NULL)
	{
		if(strncmp(buffer, "Library", 7) == 0)
		{
			if(fgets(buffer, 255, result) != NULL)
			{
				current_library = buffer;
				std::size_t end_pos = current_library.find(".") - 5;
				current_library = current_library.substr(5, end_pos);
			}
		}
		else if(strncmp(buffer, "Functions", 9) == 0)
		{
			continue;
		}
		else if(strncmp(buffer, "Function", 8) == 0)
		{
			if(fgets(buffer, 255, result) != NULL)
			{
				std::string function(buffer);

				if(strncmp(buffer, "Name,", 5) == 0)
				{
					function = function.substr(5, function.length() - 6);
					ImportData *import_data = new ImportData(current_library, function, false);
					imports.insert(imports.end(), import_data);
				}
				else if(strncmp(buffer, "Ordinal,", 8) == 0)
				{
					function = function.substr(8, function.length() - 9);
					ImportData *import_data = new ImportData(current_library, function, true);
					imports.insert(imports.end(), import_data);
				}
			}
		}
	}
	pclose(result);

	std::string pestr_command = in_file;
	pestr_command = "pestr " + pestr_command;
	const char* c_str_pestr_command = pestr_command.c_str();

	result = popen(c_str_pestr_command, "r");

	while(fgets(buffer, 255, result) != NULL)
	{
		std::string str (buffer);
		strings.insert(strings.end(), str);
	}

	// Begin running against definitions
	// Malware definition (parent class) can be initialized with values to check for in files if type of malware does not have an object

	KeyloggerDefinition keylogger;
	ScreenCaptureDefinition screen_capture;
	AntidebuggingDefinition antidebugging;

	if (output == NULL) {
		std::cout << "Probabilities that file is malicious for types of malware:" << "\n";

		std::cout << "keylogger: " << keylogger.calculateProbability(imports) << "\n";
		std::cout << "screen capture: " << screen_capture.calculateProbability(imports) << "\n";
		std::cout << "antidebugging: " << antidebugging.calculateProbability(imports) << "\n";
	}
	else
	{
		std::string return_val;

		return_val = return_val + "Probabilities that file is malicious for types of malware:" + "\n";
		return_val = return_val +  "keylogger: " + std::to_string(keylogger.calculateProbability(imports)) + "\n";
		return_val = return_val +  "screen capture: " + std::to_string(screen_capture.calculateProbability(imports)) + "\n";
		return_val = return_val +  "antidebugging: " + std::to_string(antidebugging.calculateProbability(imports)) + "\n";
		
		*output = return_val;
	}
}

void analyzeFileFromUI(GtkWidget *widget, gpointer data)
{
	GObject *text_area;
	std::string output;

	analyzeFile(*(((file_scan_data*)data)->selected_path), &output);

	const gchar *output_data = output.c_str();

	text_area = gtk_builder_get_object(((file_scan_data*)data)->builder, "outputText");

	GtkTextBuffer *buffer = gtk_text_buffer_new (NULL);

	gtk_text_buffer_set_text(buffer, output_data, output.length());
	gtk_text_view_set_buffer((GtkTextView*)text_area, buffer);
}

void loadUI(char *arg_zero)
{
	std::string selected_path;

	GtkBuilder *builder;
	GObject *window;
	GObject *button;
	GError *error = NULL;

	int init_1 = 1;
	char *init_2_arr[1];
	init_2_arr[0] = arg_zero;
	char **init_2 = &init_2_arr[0];

	gtk_init(&init_1, &init_2);

	builder = gtk_builder_new();
	if (gtk_builder_add_from_file(builder, "builder.ui", &error) == 0)
	{
		g_printerr ("Error loading file: %s\n", error->message);
	        g_clear_error (&error);
	        exit(1);
	}

	window = gtk_builder_get_object(builder, "window");
	g_signal_connect(window, "destroy", G_CALLBACK(gtk_main_quit), NULL);

	button = gtk_builder_get_object(builder, "fileSelector");
	g_signal_connect(button, "file-set", G_CALLBACK(setFile), &selected_path);

	file_scan_data data;
	data.builder = builder;
	data.selected_path = &selected_path;

	button = gtk_builder_get_object(builder, "scanButton");
	g_signal_connect(button, "clicked", G_CALLBACK(analyzeFileFromUI), &data);

	gtk_main();
}

int main(int argc, char **argv)
{
	if (argc != 2)
	{
		std::cout << "One argument must be entered." << "\n" << "arguments can be the following:" << "\n" << "<file path>: Path to file you wish to analyze" << "\n" << "-g: Run program with GUI" << "\n";
		exit(1);
	}
	else if (strncmp(argv[1], "-g", 2) == 0)
	{
		loadUI(argv[0]);
	}
	else
	{
		std::string in_file (argv[1]);
		analyzeFile(in_file);
	}
}

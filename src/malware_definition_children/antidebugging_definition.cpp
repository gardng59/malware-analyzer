#include "../import_data.h"
#include "../malware_definition.h"
#include "antidebugging_definition.h"
#include <vector>
#include <string>
#include <iostream>

AntidebuggingDefinition::AntidebuggingDefinition(): MalwareDefinition()
{
	this->name = "antidebugging";

	std::vector<ImportData*> imports;

	this->imports_used = imports;
}

double AntidebuggingDefinition::calculateProbability(std::vector<ImportData*> imports)
{
	double probability = 0;

	std::string is_debugger_present ("kernel32.isdebuggerpresent");
	bool is_debugger_present_matched = false;
	std::string check_remote_debugger_present ("kernel32.checkremotedebuggerpresent");
	bool check_remote_debugger_present_matched = false;
	std::string create_tl_help_32 ("kernel32.createtoolhelp32snapshot");
	bool create_tl_help_32_matched = false;
	std::string enum_proc_k32 ("kernel32.enumprocesses");
	std::string enum_proc_psapi ("psapi.enumprocesses");
	bool enum_proc_matched = false;
	std::string set_file_time ("kernel32.setfiletime");
	bool set_file_time_matched = false;
	std::string sleep ("kernel32.sleep");
	bool sleep_matched = false;
	std::string find_window ("user32.findwindow");
    std::string find_window_a ("user32.findwindowa");
    std::string find_window_w ("user32.findwindoww");
    std::string find_window_ex ("user32.findwindowex");
    std::string find_window_exa ("user32.findwindowexa");
    std::string find_window_exw ("user32.findwindowexw");
    bool find_window_matched = false;
    std::string get_tick_cnt ("kernel32.gettickcount");
    bool get_tick_cnt_matched = false;
    std::string output_dbg_str ("kernel32.outputdebugstring");
    std::string output_dbg_str_a ("kernel32.outputdebugstringa");
    std::string output_dbg_str_w ("kernel32.outputdebugstringw");
    bool output_dbg_str_matched = false;
    std::string process_32_first ("kernel32.process32first");
    bool process_32_first_matched = false;
    std::string process_32_next ("kernel32.process32next");
    bool process_32_next_matched = false;
    std::string query_perf_cnt ("kernel32.queryperformancecounter");
    bool query_perf_cnt_matched = false;
    std::string time_get_time ("winmm.timegettime");
    bool time_get_time_matched = false;


	for (std::vector<ImportData*>::iterator iter = imports.begin(); iter != imports.end(); iter++)
    {
        std::string *curr_string ((*iter)->toString());

        for (unsigned i = 0; i < curr_string->size(); i++)
        {
                char lower_char = (char)tolower(curr_string->at(i));
                char lower_c_str[1];
                lower_c_str[0] = lower_char;
                std::string lower (&lower_c_str[0]);
                curr_string->replace(i, 1, lower);
        }

        if (*curr_string == is_debugger_present)
        {
            is_debugger_present_matched = true;
            continue;
        }
		if (*curr_string == check_remote_debugger_present)
		{
			check_remote_debugger_present_matched = true;
			continue;
		}
		if (*curr_string == create_tl_help_32)
		{
			create_tl_help_32_matched = true;
			continue;
		}
		if (*curr_string == enum_proc_k32 || *curr_string == enum_proc_psapi)
		{
			enum_proc_matched = true;
			continue;
		}
		if (*curr_string == set_file_time)
		{
			set_file_time_matched = true;
			continue;
		}
		if (*curr_string == sleep)
		{
			sleep_matched = true;
			continue;
		}
		if (*curr_string == find_window || *curr_string == find_window_a || *curr_string == find_window_w || *curr_string == find_window_ex || *curr_string == find_window_exa || *curr_string == find_window_exw)
        {
                find_window_matched = true;
                continue;
        }
        if (*curr_string == get_tick_cnt)
        {
                get_tick_cnt_matched = true;
                continue;
        }
        if (*curr_string == output_dbg_str || *curr_string == output_dbg_str_a || *curr_string == output_dbg_str_w)
        {
                output_dbg_str_matched = true;
                continue;
        }
        if (*curr_string == process_32_first)
        {
                process_32_first_matched = true;
                continue;
        }
        if (*curr_string == process_32_next)
        {
                process_32_next_matched = true;
                continue;
        }
        if (*curr_string == query_perf_cnt)
        {
                query_perf_cnt_matched = true;
                continue;
        }
        if (*curr_string == time_get_time)
        {
                time_get_time_matched = true;
                continue;
        }
	}

	if (is_debugger_present_matched || check_remote_debugger_present_matched || create_tl_help_32_matched || enum_proc_matched || set_file_time_matched || sleep_matched)
	{
		probability = 50;

		if (is_debugger_present_matched)
		{
			probability += 5;
		}
		if (check_remote_debugger_present_matched)
		{
			probability += 5;
		}
		if (create_tl_help_32_matched)
		{
			probability += 5;
		}
		if (enum_proc_matched)
		{
			probability += 5;
		}
		if (set_file_time_matched)
		{
			probability += 5;
		}
		if (sleep_matched)
		{
			probability += 5;
		}
	}
    
    if (find_window_matched || get_tick_cnt_matched || output_dbg_str_matched || process_32_first_matched || process_32_next_matched || query_perf_cnt_matched || time_get_time_matched)
    {
    	int increment;

    	if (probability < 50)
	    {
	    	probability = 30;
	    	increment = 5;
	    }
	    else
	    {
	    	increment = 3;
	    }

	    if (find_window_matched)
	    {
	            probability += increment;
	    }

	    if (get_tick_cnt_matched)
	    {
	            probability += increment;
	    }

	    if (output_dbg_str_matched)
	    {
	            probability += increment;
	    }

	    if (process_32_first_matched)
	    {
	            probability += increment;
	    }

	    if (process_32_next_matched)
	    {
	            probability += increment;
	    }

	    if (query_perf_cnt_matched)
	    {
	            probability += increment;
	    }

	    if (time_get_time_matched)
	    {
	            probability += increment;
	    }
    }
	
	return probability;
}
